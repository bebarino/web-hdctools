{"version":3,"file":"bc8fdc5b.js","sources":["../src/actions/console.js","../src/reducers/console.js","../src/device/lib.js","../components/hdctools_console_view/hdctools-console-view.js","../components/hdctools_consoles_viewer/hdctools-consoles-viewer.js"],"sourcesContent":["export const CONSOLE_INTERFACES_FOUND = 'CONSOLE_INTERFACES_FOUND';\nexport const CONSOLE_OPENED = 'CONSOLE_OPENED';\n\nimport { currentDeviceSelector } from './device.js';\nimport { updateLocationURL } from './app.js';\nimport { createSelector } from 'reselect';\n\nconst consoleInterfacesFound = items => {\n  return {\n    type: CONSOLE_INTERFACES_FOUND,\n    items,\n  };\n};\n\nexport const discoverConsoles = (dispatch, getState) => {\n  const device = currentDeviceSelector(getState());\n\n  /* only care about interfaces that are consoles */\n  const interfaces = device.configuration.interfaces.filter(intf => {\n    for (const alt of intf.alternates) {\n      if (alt.interfaceClass == 255 && alt.interfaceSubclass == 80) {\n        return true;\n      }\n    }\n    return false;\n  });\n\n  dispatch(consoleInterfacesFound(interfaces));\n};\n\nexport const selectConsole = index => (dispatch, getState) => {\n  const state = getState();\n  const device = currentDeviceSelector(state);\n\n  dispatch(updateLocationURL(`/consoles/${device.serialNumber}/${index}`));\n};\n\nconst locationSelector = state => state.app.location;\nconst consoleSelector = state => state.consoles.items;\n\nexport const currentConsoleSelector = createSelector(\n  locationSelector,\n  consoleSelector,\n  (location, interfaces) =>\n    interfaces ? interfaces[location.split('/')[3]] : null\n);\n","import {\n  CONSOLE_OPENED,\n  CONSOLE_INTERFACES_FOUND,\n} from '../actions/console.js';\n\nconst INITIAL_STATE = {};\n\nexport const consoles = (state = INITIAL_STATE, action) => {\n  switch (action.type) {\n    case CONSOLE_OPENED:\n      return {\n        ...state,\n        endpoint: action.endpoint,\n        intf: action.interface,\n      };\n    case CONSOLE_INTERFACES_FOUND:\n      return {\n        ...state,\n        items: [...action.items],\n      };\n    default:\n      return state;\n  }\n};\n","export class UsbConsole {\n  constructor(device, intf) {\n    this._device = device;\n    this._intf = intf;\n  }\n\n  async open() {\n    const intfNumber = this._intf.interfaceNumber;\n    const device = this._device;\n\n    try {\n      this.opening = device.claimInterface(intfNumber);\n    } catch (e) {\n      console.log(`Can't claim ${device} interface ${intfNumber}`);\n    }\n  }\n\n  async readloop(onRx) {\n    const decoder = new TextDecoder();\n    const device = this._device;\n    /* Seems that sometimes the Promise hasn't completed yet */\n    if (this._intf.alternate === null) {\n      await this.opening;\n    }\n    const ep = this._intf.alternate.endpoints.find(e => e.direction == 'in');\n\n    /* TODO: Replace with webworker and a message to stop */\n    /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n    while (true) {\n      const { status, data } = await device.transferIn(\n        ep.endpointNumber,\n        ep.packetSize\n      );\n\n      if (data) {\n        onRx(decoder.decode(data));\n      }\n\n      if (status == 'stall') break;\n      if (status == 'babble') console.log(\"USB is babbling... that's bad\");\n    }\n  }\n\n  async sendStr(str) {\n    const device = this._device;\n    const ep = this._intf.alternate.endpoints.find(e => e.direction == 'out');\n    const encoded = new TextEncoder().encode(str);\n\n    await device.transferOut(ep.endpointNumber, encoded);\n  }\n\n  async close() {\n    const intf = this._intf;\n    const device = this._device;\n\n    try {\n      await device.releaseInterface(intf.interfaceNumber);\n    } catch (e) {\n      console.log(`Can't release ${device} interface ${intf.interfaceNumber}`);\n    }\n  }\n}\n\nexport class ServoUSBDevice {\n  constructor(device) {\n    this.device = device;\n  }\n\n  probeConsoles() {\n    const device = this.device;\n\n    this.consoles = device.configuration.interfaces\n      .filter(intf => {\n        for (const alt of intf.alternates) {\n          if (alt.interfaceClass == 255 && alt.interfaceSubclass == 80) {\n            return true;\n          }\n        }\n        return false;\n      })\n      .map(intf => new UsbConsole(device, intf));\n  }\n\n  async open() {\n    const device = this.device;\n\n    await device.open();\n    if (device.configuration === null) {\n      device.selectConfiguration(1);\n    }\n  }\n\n  async close() {\n    const device = this.device;\n    await device.close();\n  }\n}\n\n/* Override this to send data receieved from console to the UI \nusbConsole.prototype.onRx = str => {\n  console.log(`RX: ${str}`);\n};*/\n","// The element for a single terminal window\nimport { hterm } from '../../assets/hterm_all.js';\nimport { connect } from 'pwa-helpers';\nimport { store } from '../../src/store.js';\n\nimport { html, css } from 'lit-element';\n\nimport { PageViewElement } from '../page-view-element.js';\n\nimport { UsbConsole } from '../../src/device/lib.js';\n\nclass HdctoolsConsoleView extends connect(store)(PageViewElement) {\n  static get styles() {\n    return [\n      css`\n        #terminal {\n          width: 95%;\n          height: 90%;\n          position: fixed;\n        }\n      `,\n    ];\n  }\n\n  render() {\n    /* const { _item } = this;\n    if (_item) {\n      const info = _item.volumeInfo;\n      updateMetadata({\n        title: `${info.title} - Books`,\n        description: info.description,\n        image: info.imageLinks.thumbnail.replace(\"http\", \"https\")\n      });\n    } */\n\n    return html` <div id=\"terminal\"></div> `;\n  }\n\n  static get properties() {\n    return {\n      device: { type: Object },\n      intf: { type: Object },\n    };\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    const usbBack = (this.usbBack = new UsbConsole(this.device, this.intf));\n    usbBack.open();\n  }\n\n  firstUpdated() {\n    this._terminal = this.shadowRoot.querySelector('#terminal');\n    const usbBack = this.usbBack;\n\n    // opt_profileName is the name of the terminal profile to load, or \"default\" if\n    // not specified.  If you're using one of the persistent storage\n    // implementations then this will scope all preferences read/writes to this\n    // name.\n    const term = (this._term = new hterm.Terminal('default'));\n    term.onTerminalReady = function () {\n      // Create a new terminal IO object and give it the foreground.\n      // (The default IO object just prints warning messages about unhandled\n      // things to the the JS console.)\n      const io = term.io.push();\n\n      io.onVTKeystroke = io.sendString = str => {\n        usbBack.sendStr(str);\n      };\n\n      /* TODO: Handle this?\n      io.onTerminalResize = (columns, rows) => {\n        // React to size changes here.\n      };\n      */\n    };\n\n    term.decorate(this._terminal);\n    usbBack.readloop(str => {\n      term.io.print(str);\n    });\n    term.installKeyboard();\n  }\n}\n\nwindow.customElements.define('hdctools-console-view', HdctoolsConsoleView);\n","import '@material/mwc-button';\nimport '@material/mwc-dialog';\nimport '@material/mwc-drawer';\nimport '@material/mwc-icon-button';\nimport '@material/mwc-list';\nimport '@material/mwc-tab-bar';\n\nimport { html, css } from 'lit-element';\nimport { PageViewElement } from '../page-view-element.js';\nimport { connect } from 'pwa-helpers';\n\nimport { store } from '../../src/store.js';\n\nimport { openDevice, currentDeviceSelector } from '../../src/actions/device.js';\nimport {\n  discoverConsoles,\n  selectConsole,\n  currentConsoleSelector,\n} from '../../src/actions/console.js';\nimport { consoles } from '../../src/reducers/console.js';\nimport '../hdctools_console_view/hdctools-console-view.js';\n\nstore.addReducers({ consoles });\n\nclass HdctoolsConsolesViewer extends connect(store)(PageViewElement) {\n  constructor() {\n    super();\n  }\n\n  static get styles() {\n    return [\n      css`\n        ._console {\n          display: none;\n        }\n        ._console[active] {\n          display: block;\n        }\n      `,\n    ];\n  }\n\n  static get properties() {\n    return {\n      _consoles: { type: Array },\n      _device: { type: Object },\n      _intf: { type: Object },\n    };\n  }\n\n  render() {\n    const { _consoles, _device, _intf } = this;\n\n    return html`\n      <mwc-tab-bar\n        @MDCTabBar:activated=\"${e => {\n          const index = e.detail.index;\n          store.dispatch(selectConsole(index));\n        }}\"\n      >\n        ${_consoles.map(\n          () => html`<mwc-tab label=\"Console\" icon=\"computer\"></mwc-tab>`\n        )}\n      </mwc-tab-bar>\n      <div id=\"consoles\">\n        ${_consoles.map(\n          intf =>\n            html`\n              <hdctools-console-view\n                class=\"_console\"\n                .device=${_device}\n                .intf=${intf}\n                ?active=\"${_device === _device && intf === _intf}\"\n              ></hdctools-console-view>\n            `\n        )}\n      </div>\n    `;\n  }\n\n  firstUpdated() {\n    this.terminals = this.shadowRoot.querySelector('#consoles');\n  }\n\n  stateChanged(state) {\n    this._consoles = state.consoles.items;\n    this._device = currentDeviceSelector(state);\n    this._intf = currentConsoleSelector(state);\n  }\n\n  createTerminalElement(intf) {\n    // opt_profileName is the name of the terminal profile to load, or \"default\" if\n    // not specified.  If you're using one of the persistent storage\n    // implementations then this will scope all preferences read/writes to this\n    // name.\n\n    //const fragment = new DocumentFragment();\n    const template = html`\n      <hdctools-console-view\n        .device=${this.device}\n        .intf=${intf}\n      ></hdctools-console-view>\n    `;\n    //render(template, fragment);\n\n    return template;\n\n    //return this.terminals.appendChild(fragment);\n  }\n}\n\ncustomElements.define('hdctools-consoles-viewer', HdctoolsConsolesViewer);\n\nexport { openDevice, discoverConsoles };\n"],"names":["discoverConsoles","dispatch","getState","interfaces","currentDeviceSelector","configuration","filter","intf","alt","alternates","interfaceClass","interfaceSubclass","type","items","currentConsoleSelector","createSelector","state","app","location","consoles","split","INITIAL_STATE","UsbConsole","constructor","device","this","_device","_intf","intfNumber","interfaceNumber","opening","claimInterface","e","console","log","onRx","decoder","TextDecoder","alternate","ep","endpoints","find","direction","status","data","transferIn","endpointNumber","packetSize","decode","str","encoded","TextEncoder","encode","transferOut","releaseInterface","HdctoolsConsoleView","connect","store","PageViewElement","styles","css","render","html","Object","connectedCallback","super","usbBack","open","firstUpdated","_terminal","shadowRoot","querySelector","term","_term","hterm","Terminal","onTerminalReady","io","push","onVTKeystroke","sendString","sendStr","decorate","readloop","print","installKeyboard","window","customElements","define","addReducers","action","endpoint","interface","HdctoolsConsolesViewer","_consoles","Array","index","detail","updateLocationURL","serialNumber","selectConsole","map","terminals","stateChanged","createTerminalElement"],"mappings":"qPAcaA,EAAmB,CAACC,EAAUC,KACzC,MAGMC,EAHSC,EAAsBF,KAGXG,cAAcF,WAAWG,OAAOC,IACxD,IAAK,MAAMC,KAAOD,EAAKE,WACrB,GAA0B,KAAtBD,EAAIE,gBAAkD,IAAzBF,EAAIG,kBACnC,oBAMNV,EAnBO,CACLW,KAToC,2BAUpCC,MAiB8BV,KAarBW,EAAyBC,EAHbC,GAASA,EAAMC,IAAIC,SACpBF,GAASA,EAAMG,SAASN,MAK9C,CAACK,EAAUf,IACTA,EAAaA,EAAWe,EAASE,MAAM,KAAK,IAAM,MCvChDC,EAAgB,SCLTC,EACXC,YAAYC,EAAQjB,GAClBkB,KAAKC,QAAUF,EACfC,KAAKE,MAAQpB,eAIb,MAAMqB,EAAaH,KAAKE,MAAME,gBACxBL,EAASC,KAAKC,QAEpB,IACED,KAAKK,QAAUN,EAAOO,eAAeH,SAC9BI,GACPC,QAAQC,mBAAmBV,eAAoBI,qBAIpCO,GACb,MAAMC,EAAU,IAAIC,YACdb,EAASC,KAAKC,QAES,OAAzBD,KAAKE,MAAMW,sBACFR,cAEPS,EAAKd,KAAKE,MAAMW,UAAUE,UAAUC,KAAKT,GAAoB,MAAfA,EAAEU,WAItD,OAAa,CACX,MAAMC,OAAEA,EAAFC,KAAUA,SAAepB,EAAOqB,WACpCN,EAAGO,eACHP,EAAGQ,eAGDH,GACFT,EAAKC,EAAQY,OAAOJ,IAGR,SAAVD,EAAmB,MACT,UAAVA,GAAoBV,QAAQC,IAAI,gDAI1Be,GACZ,MAAMzB,EAASC,KAAKC,QACda,EAAKd,KAAKE,MAAMW,UAAUE,UAAUC,KAAKT,GAAoB,OAAfA,EAAEU,WAChDQ,GAAU,IAAIC,aAAcC,OAAOH,SAEnCzB,EAAO6B,YAAYd,EAAGO,eAAgBI,iBAI5C,MAAM3C,EAAOkB,KAAKE,MACZH,EAASC,KAAKC,QAEpB,UACQF,EAAO8B,iBAAiB/C,EAAKsB,uBAC5BG,GACPC,QAAQC,qBAAqBV,eAAoBjB,EAAKsB,qBC/C5D,MAAM0B,UAA4BC,EAAQC,EAARD,CAAeE,IAC/CC,oBACE,MAAO,CACLC,6DAUJC,SAWE,OAAOC,iEAIP,MAAO,CACLtC,OAAQ,CAAEZ,KAAMmD,QAChBxD,KAAM,CAAEK,KAAMmD,SAIlBC,oBACEC,MAAMD,qBAEWvC,KAAKyC,QAAU,IAAI5C,EAAWG,KAAKD,OAAQC,KAAKlB,OACzD4D,OAGVC,eACE3C,KAAK4C,UAAY5C,KAAK6C,WAAWC,cAAc,aAC/C,MAAML,EAAUzC,KAAKyC,QAMfM,EAAQ/C,KAAKgD,MAAQ,IAAIC,EAAMC,SAAS,WAC9CH,EAAKI,gBAAkB,WAIrB,MAAMC,EAAKL,EAAKK,GAAGC,OAEnBD,EAAGE,cAAgBF,EAAGG,WAAa/B,IACjCiB,EAAQe,QAAQhC,KAUpBuB,EAAKU,SAASzD,KAAK4C,WACnBH,EAAQiB,SAASlC,IACfuB,EAAKK,GAAGO,MAAMnC,KAEhBuB,EAAKa,mBAITC,OAAOC,eAAeC,OAAO,wBAAyBjC,GChEtDE,EAAMgC,YAAY,CAAEtE,SHfI,CAACH,EAAQK,EAAeqE,KAC9C,OAAQA,EAAO9E,MACb,IDR0B,iBCSxB,cACKI,OACH2E,SAAUD,EAAOC,SACjBpF,KAAMmF,EAAOE,YAEjB,IDfoC,2BCgBlC,cACK5E,OACHH,MAAO,IAAI6E,EAAO7E,SAEtB,QACE,OAAOG,MGGb,MAAM6E,UAA+BrC,EAAQC,EAARD,CAAeE,IAClDnC,cACE0C,4BAIA,MAAO,CACLL,8FAYF,MAAO,CACLkC,UAAW,CAAElF,KAAMmF,OACnBrE,QAAS,CAAEd,KAAMmD,QACjBpC,MAAO,CAAEf,KAAMmD,SAInBF,SACE,MAAMiC,UAAEA,EAAFpE,QAAaA,EAAbC,MAAsBA,GAAUF,KAEtC,OAAOqC,gDAAP,OAAA,wCAAA,aAE4B9B,IACtB,MAAMgE,EAAQhE,EAAEiE,OAAOD,MACvBvC,EAAMxD,SJ3Ba+F,CAAAA,GAAS,CAAC/F,EAAUC,KAC/C,MAAMc,EAAQd,IACRsB,EAASpB,EAAsBY,GAErCf,EAASiG,eAA+B1E,EAAO2E,gBAAgBH,OIuBxCI,CAAcJ,KAG7BF,EAAUO,IACV,IAAMvC,kEAINgC,EAAUO,IACV9F,GACEuD,8DADE,aAAA,eAAA,gCAIYpC,EACFnB,EACGmB,GAAYA,GAAWnB,IAASoB,KAQzDyC,eACE3C,KAAK6E,UAAY7E,KAAK6C,WAAWC,cAAc,aAGjDgC,aAAavF,GACXS,KAAKqE,UAAY9E,EAAMG,SAASN,MAChCY,KAAKC,QAAUtB,EAAsBY,GACrCS,KAAKE,MAAQb,EAAuBE,GAGtCwF,sBAAsBjG,GAepB,OARiBuD,6CAAH,aAAA,gCAEArC,KAAKD,OACPjB,IAWhBgF,eAAeC,OAAO,2BAA4BK"}